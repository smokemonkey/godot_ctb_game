<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTBç³»ç»Ÿæ¼”ç¤º - å›åˆåˆ¶æˆ˜æ–—æ—¶é—´ç®¡ç†</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fomantic-ui@2.9.3/dist/semantic.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.9.3/dist/semantic.min.css">
    <script src="/config.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Microsoft YaHei', 'Simhei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr 350px;
            gap: 20px;
            padding: 20px;
            min-height: 600px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #3498db;
        }

        .panel h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }

        .info-text {
            font-family: 'Courier New', monospace;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            white-space: pre-line;
            font-size: 13px;
            line-height: 1.4;
            max-height: 200px;
            overflow-y: auto;
        }

        .scrollable-log {
            max-height: 300px;
            overflow-y: auto;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
        }

        .control-group h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin: 5px 0;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.success {
            background: linear-gradient(135deg, #27ae60 0%, #219a52 100%);
        }

        .btn.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .btn.danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }

        .input-group label {
            color: #2c3e50;
            font-weight: bold;
            min-width: 80px;
        }

        .input-group input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
        }

        .input-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #3498db #2c3e50;
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }

        .info-text, .scrollable-log {
            scrollbar-width: thin;
            scrollbar-color: #3498db #2c3e50;
        }

        .info-text::-webkit-scrollbar, .scrollable-log::-webkit-scrollbar {
            width: 6px;
        }

        .info-text::-webkit-scrollbar-track, .scrollable-log::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .info-text::-webkit-scrollbar-thumb, .scrollable-log::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="app" class="ui container">
        <div class="container">
            <div class="header">
                <h1>ğŸº CTBç³»ç»Ÿæ¼”ç¤º</h1>
                <p>åŸºäºæ˜¥ç§‹æ—¶ä»£çš„å›åˆåˆ¶æˆ˜æ–—æ—¶é—´ç®¡ç†ç³»ç»Ÿ</p>
            </div>

            <div class="content">
                <!-- å·¦ä¾§é¢æ¿ -->
                <div>
                    <div class="panel">
                        <h3>ğŸ“… æ—¶é—´ä¿¡æ¯</h3>
                        <div class="info-text" id="timeInfo">ç­‰å¾…åˆå§‹åŒ–...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>ğŸ‘¥ è§’è‰²ä¿¡æ¯</h3>
                        <div class="info-text" id="characterInfo">ç­‰å¾…åˆå§‹åŒ–...</div>
                    </div>
                </div>

                <!-- ä¸­é—´é¢æ¿ -->
                <div>
                    <div class="panel">
                        <h3>âš”ï¸ CTBçŠ¶æ€</h3>
                        <div class="info-text" id="ctbStatus">ç­‰å¾…åˆå§‹åŒ–...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>â³ è¡ŒåŠ¨é˜Ÿåˆ—</h3>
                        <div class="info-text" id="actionQueue">ç­‰å¾…åˆå§‹åŒ–...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>ğŸ”­ è¡ŒåŠ¨é¢„æµ‹</h3>
                        <div class="info-text" id="predictionBar">ç­‰å¾…åˆå§‹åŒ–...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>ğŸ“œ è¡ŒåŠ¨å†å²</h3>
                        <div class="scrollable-log" id="actionHistory">ç­‰å¾…è¡ŒåŠ¨...</div>
                    </div>
                </div>

                <!-- æ§åˆ¶é¢æ¿ -->
                <div class="controls">
                    <div class="control-group">
                        <h4>âš™ï¸ ç³»ç»Ÿæ§åˆ¶</h4>
                        <button class="btn success" onclick="initializeCTB()">ğŸš€ åˆå§‹åŒ–CTB</button>
                        <button class="btn" onclick="executeNextAction()">â–¶ï¸ æ‰§è¡Œä¸‹ä¸ªè¡ŒåŠ¨</button>
                        <button class="btn warning" onclick="skipToNext()">â­ï¸ è·³è½¬æ—¶é—´</button>
                        <button class="btn danger" onclick="resetCTB()">ğŸ”„ é‡ç½®ç³»ç»Ÿ</button>
                    </div>

                    <div class="control-group">
                        <h4>ğŸ›ï¸ å‚æ•°è°ƒæ•´</h4>
                        <div class="input-group">
                            <label>åŸºç¡€å› å­:</label>
                            <input type="number" id="factorInput" value="100" min="1" max="1000">
                            <button class="btn" onclick="changeBaseFactor()" style="width: auto; margin: 0;">è®¾ç½®</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>ğŸ® æµ‹è¯•åŠŸèƒ½</h4>
                        <button class="btn" onclick="toggleCharacterActive()">ğŸ”„ åˆ‡æ¢è§’è‰²çŠ¶æ€</button>
                        <button class="btn" onclick="addRandomCharacter()">â• æ·»åŠ éšæœºè§’è‰²</button>
                        <button class="btn warning" onclick="runStressTest()">ğŸš€ åˆå§‹åŒ– (å‹æµ‹æ¨¡å¼)</button>
                    </div>

                    <div class="control-group">
                        <h4>ğŸ“Š ç³»ç»ŸçŠ¶æ€</h4>
                        <div style="font-size: 12px; color: #7f8c8d;">
                            <div>ç³»ç»ŸçŠ¶æ€: <span id="systemStatus" style="font-weight: bold;">æœªåˆå§‹åŒ–</span></div>
                            <div>è§’è‰²æ•°é‡: <span id="characterCount">0</span></div>
                            <div>è¡ŒåŠ¨æ€»æ•°: <span id="actionCount">0</span></div>
                            <div id="stressTestResult" style="margin-top: 10px; white-space: pre-wrap; font-weight: bold; color: #27ae60; font-size: 13px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ¨¡æ‹Ÿçš„åç«¯æ•°æ®
        let gameState = {
            timeManager: {
                currentYear: window.gameConfig.EPOCH_START_YEAR,
                currentMonth: 1,
                currentDay: 1,
                currentHour: 0,
                totalHours: 0
            },
            ctbManager: {
                isInitialized: false,
                baseFactor: 100,
                characters: [],
                actionQueue: [],
                actionHistory: [],
                nextActionId: 1
            }
        };

        // æµ‹è¯•è§’è‰²æ•°æ® (å¯¹åº” examples/data/ctb_characters.py ä¸­çš„åŸºç¡€è§’è‰²ç»„)
        const testCharacters = [
            { id: 1, name: "å¼ ä¸‰", faction: "èœ€å›½", speed: 5, isActive: true },
            { id: 2, name: "æå››", faction: "é­å›½", speed: 7, isActive: true },
            { id: 3, name: "ç‹äº”", faction: "å´å›½", speed: 10, isActive: true }
        ];

        // æ›´æ–°æ‰€æœ‰æ˜¾ç¤º
        function updateAllDisplays() {
            updateTimeDisplay();
            updateCTBStatus();
            updateCharacterInfo();
            updateActionQueue();
            updatePredictionBar();
            updateSystemStatus();
        }

        // æ›´æ–°æ—¶é—´æ˜¾ç¤º
        function updateTimeDisplay() {
            const tm = gameState.timeManager;
            const year = Math.abs(tm.currentYear);
            const era = tm.currentYear < 0 ? "å…¬å…ƒå‰" : "å…¬å…ƒ";
            const eraYear = tm.currentYear - window.gameConfig.EPOCH_START_YEAR + 1;

            const timeText = `å½“å‰æ—¶é—´: ${era}${year}å¹´${tm.currentMonth}æœˆ${tm.currentDay}æ—¥${tm.currentHour}ç‚¹
çºªå¹´: æ˜¥ç§‹${eraYear}å¹´${tm.currentMonth}æœˆ${tm.currentDay}æ—¥${tm.currentHour}ç‚¹
æ€»è®¡å°æ—¶: ${tm.totalHours}
æ€»è®¡å¤©æ•°: ${Math.floor(tm.totalHours / 24)}`;

            document.getElementById('timeInfo').textContent = timeText;
        }

        // æ›´æ–°CTBçŠ¶æ€
        function updateCTBStatus() {
            const ctb = gameState.ctbManager;
            const statusText = `ç³»ç»ŸçŠ¶æ€: ${ctb.isInitialized ? 'å·²åˆå§‹åŒ–' : 'æœªåˆå§‹åŒ–'}
åŸºç¡€å› å­: ${ctb.baseFactor}
æ´»è·ƒè§’è‰²: ${ctb.characters.filter(c => c.isActive).length}/${ctb.characters.length}
é˜Ÿåˆ—é•¿åº¦: ${ctb.actionQueue.length}
å†å²è®°å½•: ${ctb.actionHistory.length}`;

            document.getElementById('ctbStatus').textContent = statusText;
        }

        // æ›´æ–°è§’è‰²ä¿¡æ¯
        function updateCharacterInfo() {
            const characters = gameState.ctbManager.characters;
            let text = `=== è§’è‰²åˆ—è¡¨ (å…± ${characters.length} ä¸ª) ===\n`;
            const displayLimit = 20;

            const charactersToShow = characters.slice(0, displayLimit);

            charactersToShow.forEach(char => {
                const status = char.isActive ? "âœ“" : "âœ—";
                const interval = Math.ceil(gameState.ctbManager.baseFactor / char.speed);
                text += `${status} ${char.name} (${char.faction})\n`;
                text += `  é€Ÿåº¦:${char.speed.toFixed(2)} é—´éš”:${interval}å¤©\n`;
            });

            if (characters.length > displayLimit) {
                text += `\n... (ä»…æ˜¾ç¤ºå‰ ${displayLimit} ä¸ªè§’è‰²)`;
            }

            document.getElementById('characterInfo').textContent = text;
        }

        // æ›´æ–°è¡ŒåŠ¨é˜Ÿåˆ—
        function updateActionQueue() {
            const queue = gameState.ctbManager.actionQueue;
            let text = "=== è¡ŒåŠ¨é˜Ÿåˆ— ===\n";

            queue.slice(0, 8).forEach((action, index) => {
                const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
                const days = Math.floor(timeUntil / 24);
                const hours = Math.floor(timeUntil % 24);

                if (index === 0) {
                    text += `â†’ ${action.characterName}\n`;
                } else {
                    text += `  ${action.characterName}\n`;
                }
                text += `    ${days}å¤©${hours}å°æ—¶å\n`;
            });

            document.getElementById('actionQueue').textContent = text;
        }

        // æ›´æ–°é¢„æµ‹æ¡
        function updatePredictionBar() {
            const predictions = predictFutureActions(10); // é¢„æµ‹æœªæ¥10ä¸ªè¡ŒåŠ¨
            let text = "=== æœªæ¥10æ¬¡è¡ŒåŠ¨é¢„æµ‹ ===\n";

            if (predictions.length === 0) {
                text = "æ— æ³•é¢„æµ‹ï¼ˆé˜Ÿåˆ—ä¸ºç©ºæˆ–æœªåˆå§‹åŒ–ï¼‰";
            } else {
                predictions.forEach((action, index) => {
                    const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
                    const days = Math.floor(timeUntil / 24);
                    const hours = Math.floor(timeUntil % 24);

                    text += `${String(index + 1).padStart(2, ' ')}. ${action.characterName}\n`;
                    text += `     å°†åœ¨ ${days}å¤©${hours}å°æ—¶åè¡ŒåŠ¨\n`;
                });
            }

            document.getElementById('predictionBar').textContent = text;
        }

        // æ›´æ–°ç³»ç»ŸçŠ¶æ€
        function updateSystemStatus() {
            const ctb = gameState.ctbManager;
            document.getElementById('systemStatus').textContent = ctb.isInitialized ? 'å·²åˆå§‹åŒ–' : 'æœªåˆå§‹åŒ–';
            document.getElementById('characterCount').textContent = ctb.characters.length;
            document.getElementById('actionCount').textContent = ctb.actionHistory.length;
        }

        // æ·»åŠ è¡ŒåŠ¨å†å²è®°å½•
        function addActionLog(message) {
            const historyDiv = document.getElementById('actionHistory');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

            historyDiv.appendChild(logEntry);
            historyDiv.scrollTop = historyDiv.scrollHeight;

            // ä¿æŒæœ€æ–°50æ¡è®°å½•
            while (historyDiv.children.length > 50) {
                historyDiv.removeChild(historyDiv.firstChild);
            }
        }

        // é¢„æµ‹æœªæ¥è¡ŒåŠ¨
        function predictFutureActions(count) {
            const ctb = gameState.ctbManager;
            if (!ctb.isInitialized || ctb.actionQueue.length === 0) {
                return [];
            }

            // ä½¿ç”¨æ·±æ‹·è´åˆ›å»ºæ¨¡æ‹Ÿç¯å¢ƒ
            let simQueue = JSON.parse(JSON.stringify(ctb.actionQueue));

            const predictions = [];

            for (let i = 0; i < count; i++) {
                if (simQueue.length === 0) break;

                // è·å–ä¸‹ä¸€ä¸ªè¡ŒåŠ¨ (JSä¸­shift()ä»æ•°ç»„å¤´éƒ¨å–å‡º)
                const nextAction = simQueue.shift();
                predictions.push(nextAction);

                // å®‰æ’è¯¥è§’è‰²çš„ä¸‹ä¸€æ¬¡è¡ŒåŠ¨
                const character = ctb.characters.find(c => c.id === nextAction.characterId);
                if (character && character.isActive) {
                    const interval = Math.ceil(ctb.baseFactor / character.speed);
                    const nextTriggerTime = nextAction.triggerTime + (interval * 24);

                    simQueue.push({
                        id: -1, // æ¨¡æ‹Ÿè¡ŒåŠ¨ID
                        characterId: character.id,
                        characterName: character.name,
                        triggerTime: nextTriggerTime,
                        actionType: 'attack'
                    });

                    // ä¿æŒæ¨¡æ‹Ÿé˜Ÿåˆ—æ’åº
                    simQueue.sort((a, b) => a.triggerTime - b.triggerTime);
                }
            }

            return predictions;
        }

        // CTBç³»ç»Ÿæ§åˆ¶å‡½æ•°
        function initializeCTB() {
            gameState.ctbManager.characters = [...testCharacters];
            gameState.ctbManager.isInitialized = true;
            gameState.ctbManager.actionQueue = [];

            // ç”Ÿæˆåˆå§‹è¡ŒåŠ¨é˜Ÿåˆ—
            gameState.ctbManager.characters.forEach(char => {
                if (char.isActive) {
                    const baseFactor = gameState.ctbManager.baseFactor;
                    const intervalDays = Math.ceil(baseFactor / char.speed);
                    const intervalHours = intervalDays * 24;

                    // é¦–æ¬¡è¡ŒåŠ¨æ—¶é—´åœ¨ (0, intervalHours] åŒºé—´å†…éšæœºåˆ†å¸ƒ
                    // è¿™é¿å…äº†æ‰€æœ‰è§’è‰²åœ¨åŒä¸€å¤©åŒæ­¥å…¶è¡ŒåŠ¨å‘¨æœŸ
                    const initialDelayHours = Math.floor(Math.random() * intervalHours) + 1;
                    const triggerTime = gameState.timeManager.totalHours + initialDelayHours;

                    gameState.ctbManager.actionQueue.push({
                        id: gameState.ctbManager.nextActionId++,
                        characterId: char.id,
                        characterName: char.name,
                        triggerTime: triggerTime,
                        actionType: 'attack'
                    });
                }
            });

            // æŒ‰è§¦å‘æ—¶é—´æ’åº
            gameState.ctbManager.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);

            addActionLog("CTBç³»ç»Ÿå·²åˆå§‹åŒ–");
            updateAllDisplays();
        }

        function executeNextAction() {
            if (!gameState.ctbManager.isInitialized) {
                addActionLog("è¯·å…ˆåˆå§‹åŒ–CTBç³»ç»Ÿ");
                return;
            }

            const action = gameState.ctbManager.actionQueue.shift();
            if (!action) {
                addActionLog("æ²¡æœ‰å¾…æ‰§è¡Œçš„è¡ŒåŠ¨");
                return;
            }

            // æ¨è¿›æ—¶é—´åˆ°è¡ŒåŠ¨æ—¶é—´
            gameState.timeManager.totalHours = action.triggerTime;
            updateTimeFromTotalHours();

            // è®°å½•è¡ŒåŠ¨
            const tm = gameState.timeManager;
            const year = Math.abs(tm.currentYear);
            const era = tm.currentYear < 0 ? "å…¬å…ƒå‰" : "å…¬å…ƒ";
            const eraYear = tm.currentYear - window.gameConfig.EPOCH_START_YEAR + 1;

            const logMessage = `æ˜¥ç§‹${eraYear}å¹´${tm.currentMonth}æœˆ${tm.currentDay}æ—¥${tm.currentHour}ç‚¹ (${era}${year}å¹´${tm.currentMonth}æœˆ${tm.currentDay}æ—¥${tm.currentHour}ç‚¹) - ${action.characterName} è¡ŒåŠ¨`;
            addActionLog(logMessage);

            // æ·»åŠ åˆ°å†å²
            gameState.ctbManager.actionHistory.push({
                ...action,
                executedTime: action.triggerTime,
                timestamp: Date.now()
            });

            // ä¸ºè¯¥è§’è‰²å®‰æ’ä¸‹æ¬¡è¡ŒåŠ¨
            const character = gameState.ctbManager.characters.find(c => c.id === action.characterId);
            if (character && character.isActive) {
                const interval = Math.ceil(gameState.ctbManager.baseFactor / character.speed);
                const nextTriggerTime = action.triggerTime + (interval * 24);

                gameState.ctbManager.actionQueue.push({
                    id: gameState.ctbManager.nextActionId++,
                    characterId: character.id,
                    characterName: character.name,
                    triggerTime: nextTriggerTime,
                    actionType: 'attack'
                });

                // é‡æ–°æ’åºé˜Ÿåˆ—
                gameState.ctbManager.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);
            }

            updateAllDisplays();
        }

        function skipToNext() {
            if (!gameState.ctbManager.isInitialized) {
                addActionLog("è¯·å…ˆåˆå§‹åŒ–CTBç³»ç»Ÿ");
                return;
            }

            const nextAction = gameState.ctbManager.actionQueue[0];
            if (!nextAction) {
                addActionLog("æ²¡æœ‰å¾…æ‰§è¡Œçš„è¡ŒåŠ¨");
                return;
            }

            // ç›´æ¥è·³è½¬æ—¶é—´
            gameState.timeManager.totalHours = nextAction.triggerTime;
            updateTimeFromTotalHours();

            addActionLog(`æ—¶é—´å·²è·³è½¬åˆ° ${nextAction.characterName} çš„è¡ŒåŠ¨æ—¶é—´`);
            updateAllDisplays();
        }

        function changeBaseFactor() {
            const newFactor = parseInt(document.getElementById('factorInput').value);
            if (newFactor && newFactor > 0) {
                gameState.ctbManager.baseFactor = newFactor;
                addActionLog(`åŸºç¡€å› å­å·²ä¿®æ”¹ä¸º: ${newFactor}`);
                updateAllDisplays();
            } else {
                addActionLog("åŸºç¡€å› å­å¿…é¡»å¤§äº0");
            }
        }

        function resetCTB(silent = false) {
            gameState.ctbManager = {
                isInitialized: false,
                baseFactor: 100,
                characters: [],
                actionQueue: [],
                actionHistory: [],
                nextActionId: 1
            };

            document.getElementById('factorInput').value = "100";
            if (!silent) {
                addActionLog("CTBç³»ç»Ÿå·²é‡ç½®");
            }
            // Clear stress test results on reset
            const resultDiv = document.getElementById('stressTestResult');
            if (resultDiv) resultDiv.textContent = "";

            updateAllDisplays();
        }

        function toggleCharacterActive() {
            if (gameState.ctbManager.characters.length > 0) {
                const char = gameState.ctbManager.characters[0];
                char.isActive = !char.isActive;
                const status = char.isActive ? "æ¿€æ´»" : "åœç”¨";
                addActionLog(`${char.name} å·²${status}`);
                updateAllDisplays();
            }
        }

        function addRandomCharacter() {
            const names = ["èµµå…­", "å­™ä¸ƒ", "å‘¨å…«", "å´ä¹", "éƒ‘å"];
            const factions = ["é½å›½", "æ¥šå›½", "ç‡•å›½", "éŸ©å›½", "èµµå›½"];

            const randomName = names[Math.floor(Math.random() * names.length)];
            const randomFaction = factions[Math.floor(Math.random() * factions.length)];
            const randomSpeed = Math.floor(Math.random() * 8) + 3; // 3-10

            const newChar = {
                id: Date.now(),
                name: randomName,
                faction: randomFaction,
                speed: randomSpeed,
                isActive: true
            };

            gameState.ctbManager.characters.push(newChar);
            addActionLog(`æ·»åŠ è§’è‰²: ${randomName}(${randomFaction}) é€Ÿåº¦:${randomSpeed}`);
            updateAllDisplays();
        }

        // ä»æ€»å°æ—¶æ•°æ›´æ–°æ—¥æœŸæ—¶é—´
        function updateTimeFromTotalHours() {
            const totalHours = gameState.timeManager.totalHours;
            const totalDays = Math.floor(totalHours / 24);
            const hours = totalHours % 24;

            // ç®€åŒ–çš„æ—¥æœŸè®¡ç®—ï¼ˆ360å¤©/å¹´ï¼Œ30å¤©/æœˆï¼‰
            const startYear = window.gameConfig.EPOCH_START_YEAR;
            const years = Math.floor(totalDays / 360);
            const remainingDays = totalDays % 360;
            const months = Math.floor(remainingDays / 30);
            const days = remainingDays % 30;

            gameState.timeManager.currentYear = startYear + years;
            gameState.timeManager.currentMonth = months + 1;
            gameState.timeManager.currentDay = days + 1;
            gameState.timeManager.currentHour = hours;
        }

        function runStressTest() {
            addActionLog("ğŸ”¥ å¼€å§‹å‹åŠ›æµ‹è¯•åˆå§‹åŒ–...");

            if (!confirm("æ‚¨ç¡®å®šè¦åˆå§‹åŒ–10,000ä¸ªè§’è‰²å—ï¼Ÿè¿™å¯èƒ½ä¼šå¯¼è‡´æµè§ˆå™¨é¡µé¢å¡é¡¿æˆ–æ— å“åº”ã€‚")) {
                addActionLog("å‹åŠ›æµ‹è¯•å·²å–æ¶ˆã€‚");
                return;
            }

            const resultDiv = document.getElementById('stressTestResult');
            resultDiv.textContent = "åˆå§‹åŒ–ä¸­...";

            setTimeout(() => {
                try {
                    // 1. é‡ç½®ç³»ç»ŸçŠ¶æ€
                    resetCTB(true);

                    // 2. è®¾ç½®å‚æ•°
                    const characterCount = 10000;
                    const averageIntervalDays = 90;
                    const baseFactor = gameState.ctbManager.baseFactor;
                    const targetSpeed = baseFactor / averageIntervalDays;

                    const newCharacters = [];
                    let totalActionsPerDay = 0;

                    // 3. ç”Ÿæˆè§’è‰²å¹¶è®¡ç®—ç†è®ºå¹³å‡å€¼
                    for (let i = 0; i < characterCount; i++) {
                        const randomFactor = 0.5 + Math.random();
                        const finalSpeed = Math.max(0.1, targetSpeed * randomFactor);

                        newCharacters.push({
                            id: Date.now() + i,
                            name: `è§’è‰²${i + 1}`,
                            faction: "å‹æµ‹",
                            speed: parseFloat(finalSpeed.toFixed(2)),
                            isActive: true
                        });

                        const intervalDays = Math.ceil(baseFactor / finalSpeed);
                        if (intervalDays > 0) {
                            totalActionsPerDay += 1 / intervalDays;
                        }
                    }
                    gameState.ctbManager.characters = newCharacters;

                    // 4. å®‰æ’é¦–æ¬¡è¡ŒåŠ¨
                    gameState.ctbManager.characters.forEach(char => {
                        const intervalDays = Math.ceil(baseFactor / char.speed);
                        const intervalHours = intervalDays * 24;

                        // é¦–æ¬¡è¡ŒåŠ¨æ—¶é—´åœ¨ (0, intervalHours] åŒºé—´å†…éšæœºåˆ†å¸ƒ
                        const initialDelayHours = Math.floor(Math.random() * intervalHours) + 1;
                        const triggerTime = gameState.timeManager.totalHours + initialDelayHours;

                        gameState.ctbManager.actionQueue.push({
                            id: gameState.ctbManager.nextActionId++,
                            characterId: char.id,
                            characterName: char.name,
                            triggerTime: triggerTime,
                            actionType: 'attack'
                        });
                    });

                    // 5. æ’åºè¡ŒåŠ¨é˜Ÿåˆ—
                    gameState.ctbManager.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);

                    gameState.ctbManager.isInitialized = true;

                    // 6. æ˜¾ç¤ºç†è®ºè®¡ç®—ç»“æœ
                    const resultText = `--- å‹åŠ›æµ‹è¯•ç»“æœ ---\nè§’è‰²æ•°é‡: ${characterCount}\nç›®æ ‡è¡ŒåŠ¨é—´éš”: ${averageIntervalDays} å¤©\nç†è®ºå¹³å‡æ¯æ—¥è¡ŒåŠ¨: ${totalActionsPerDay.toFixed(2)} äºº`;
                    resultDiv.textContent = resultText;

                    addActionLog(`âœ… å‹åŠ›æµ‹è¯•åˆå§‹åŒ–å®Œæˆï¼Œå·²ç”Ÿæˆ ${characterCount} ä¸ªè§’è‰²ã€‚`);

                    // 7. æ›´æ–°æ‰€æœ‰æ˜¾ç¤º
                    updateAllDisplays();

                } catch (e) {
                    console.error("å‹åŠ›æµ‹è¯•åˆå§‹åŒ–å‡ºé”™:", e);
                    resultDiv.textContent = "åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚";
                    addActionLog("âŒ å‹åŠ›æµ‹è¯•åˆå§‹åŒ–å¤±è´¥ã€‚");
                }
            }, 50);
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ˜¾ç¤º
        document.addEventListener('DOMContentLoaded', function() {
            updateAllDisplays();
            addActionLog("ç³»ç»Ÿå¯åŠ¨å®Œæˆï¼Œè¯·ç‚¹å‡»'åˆå§‹åŒ–CTB'å¼€å§‹");
        });
    </script>
</body>
</html>